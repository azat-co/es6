footer: © NodeProgram.com, Node.University and Azat Mardan 2017
slidenumbers: true

# Top ES6/ES2015 Features
## Section 3: Language Features

![inline 100%](images/azat.jpeg)
Azat Mardan @azat_co

![inline right](images/nu.png)

---

# Promises

---


### Promises have been a controversial development topic, especially in larger organizations where it can be harder to agree on a common approach.

---

### One reason for this is the number of promise implementations using slightly different syntaxes—q, bluebird, deferred.js, vow, avow, and jquery deferred to name just a few.

---

### Another reason is that some software engineers say, "We don't need promises and can just use async, generators, callbacks, etc".

---

### Gladly, there's a chance the debates will quiet down with the standard `Promise` implementation added to ES6!

---

Let's consider a rather trivial example of a delayed asynchronous execution with `setTimeout()`:

```js
setTimeout(function(){
  console.log('Yay!')
}, 1000)
```

---

We can re-write this code in ES6 with Promise:

```js
var wait1000 =  new Promise(function(resolve, reject) {
  setTimeout(resolve, 1000)
}).then(function() {
  console.log('Yay!')
})
```

---

Or with ES6 arrow functions and `const` (can be `let` or `var`):

```js
const wait1000 =  new Promise((resolve, reject) => {
  setTimeout(resolve, 1000)
}).then(() => {
  console.log('Yay!')
})
```

---

If we have more nested logic inside of the `setTimeout()` callback in ES5 code:

```js
setTimeout(function(){
  console.log('Yay!')
  setTimeout(function(){
    console.log('Wheeyee!')
  }, 1000)
}, 1000)
```

---

It can be re-written with ES6 promises like so:

```js
var wait1000 =  () =>  // you can pass args
  new Promise((resolve, reject) => {
    setTimeout(resolve, 1000)
  })

wait1000()
  .then(() => {
    console.log('Yay!')
    return wait1000()
  })
  .then(() => {
    console.log('Wheeyee!')
  })
```

---

As you can observe, the code organization changed when we refactored callbacks-only code into code with Promises.

---

Another benefit not covered in this essay — Promises have a fail-and-catch-all callback as well which is a nice feature.

---

[axios](https://github.com/mzabriskie/axios) example:

```js
const request = require('axios')
request.get(url)
  .then(response => response.data)
  .then(messages => {
    console.log(messages)
    if(!messages || !messages.length){
      throw 'Message is empty'
    }
    this.setState({messages: messages}) // React method
  })
  .catch( (error) {
    console.log(error)
  })  
```  

---

Take a look at this post for more info on Promises: [*Introduction to ES6 Promises*](http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell).

---

# Enhanced Object Literals

---


### What you can do with object literals in ES6 is mind blowing!

---

### ES6 object literals are not a version of JSON (ES5) but something closely resembling classes!

---

Here's a typical ES5 object literal with some methods and attributes/properties:

```js
var serviceBase = {port: 3000, url: 'azat.co'},
    getAccounts = function(){return [1,2,3]}

var accountServiceES5 = {
  port: serviceBase.port,
  url: serviceBase.url,
  getAccounts: getAccounts,
  toString: function() {
    return JSON.stringify(this.valueOf())
  },
  getUrl: function() {return "http://" + this.url + ':' + this.port},
  valueOf_1_2_3: getAccounts()
}
```

---

If we want to be fancy, we can inherit from `serviceBase` by making it the prototype with the `Object.create` method:

```js
var accountServiceES5ObjectCreate = Object.create(serviceBase)
var accountServiceES5ObjectCreate = {
  getAccounts: getAccounts,
  toString: function() {
    return JSON.stringify(this.valueOf())
  },
  getUrl: function() {return "http://" + this.url + ':' + this.port},
  valueOf_1_2_3: getAccounts()
}
```

---

I know, `accountServiceES5ObjectCreate` and `accountServiceES5` are NOT totally identical, because one object (`accountServiceES5`) will have the properties in the `__proto__` object as shown in the illustration below:

![left 100%](images/es6-1.png)

---

But for the sake of this example, let's consider them similar. In ES6 object literals, we can use shorthands for assignment. For example, `getAccounts: getAccounts,` becomes just `getAccounts,`.

---

We can also set the prototype right there in the `__proto__` property  (not `'__proto__'` though). For example, `serviceBase` is a prototype:

```js
var serviceBase = {port: 3000, url: 'azat.co'},
  getAccounts = function(){return [1,2,3]}
var accountService = {
  __proto__: serviceBase,
  getAccounts,
```

---

Also, we can invoke `super` and have dynamic keys. For example, `toString()` method returns a JSON object as a string by calling `super.valueOf()`, and `valueOf_1_2_3` is a dynamic property name:

```js
  toString() {
    return JSON.stringify((super.valueOf()))
  },
	getUrl() {return "http://" + this.url + ':' + this.port},
    [ 'valueOf_' + getAccounts().join('_') ]: getAccounts()
}
console.log(accountService)
```

---

![left 100%](images/es6-2.png)


```js
var serviceBase = {port: 3000, url: 'azat.co'}, // or const
  getAccounts = function(){return [1,2,3]}
var accountService = { // or const or let
  __proto__: serviceBase,
  getAccounts,
  toString() {
    return JSON.stringify((super.valueOf()))
  },
	getUrl() {return "http://" + this.url + ':' + this.port},
    [ 'valueOf_' + getAccounts().join('_') ]: getAccounts()
}
console.log(accountService)
```

---

This is a great enhancement to good old object literals, because developers can pack more logic and do more things than with ES5 objects!

---

# Classes

---

# Modules

